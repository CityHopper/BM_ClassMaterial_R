for (s in 1:1000){
if (s %% 3 == 0 | s %% 5 == 0){
cat(s, ' ')
count <- count + 1
if (count %% 10 == 0){
print("\n")
}
}
}
cat("Total: ", count)
cat(d1, d2)
# Q1
d1 <- 1:50
d2 <- 51:100
cat(d1, d2)
length(d2)
cat(d1); cat(d2) # Q1-1
sort(d1)
d3 <- D1[1:10] + D2[1:10]
D1 <- sort(d1) # Q1-9
D2 <- sort(d2)
d3 <- D1[1:10] + D2[1:10]
v1 <- 51:90
v1 < 60 # Q2-1
v1[v1 < 60] # Q2-1
lenth[v1 < 70]
length[v1 < 70]
sum[v1 > 65]
v1 <- 51:90
v1[v1 < 60] # Q2-1
length[v1 < 70] # Q2-2
sum[v1 > 65]
sum[v1 [v1> 65]]
sum(v1 [v1> 65])
cond <- v1 < 65 & v1 > 80 # Q2-5
cond
d[cond]
v1[cond]
cond <- v1 < 65 & v1 > 80 # Q2-5
v1[cond]
cat(d1, d2) # Q1-1
# Q1
d1 <- 1:50
d2 <- 51:100
cat(d1, d2) # Q1-1
length(d2) # Q1-2
d1 + d2 # Q1-3
d2 - d1
d1 * d2
d2 / d1
sum(d1) # Q1-4
sum(d2)
sum(d1+d2) # Q1-5
max(d2); min(d2) # Q1-6
mean(d2) - mean(d1) # Q1-7
sort(d1, decreasing = TRUE) # Q1-8
D1 <- sort(d1) # Q1-9
D2 <- sort(d2)
d3 <- D1[1:10] + D2[1:10]
D1 <- sort(d1) # Q1-9 d1, d2  오름차순으로 정렬 후 각 10개씩을 추출하여 d3에 저장
D2 <- sort(d2)
d3 <- D1[1:10] + D2[1:10]
# Q1-8
D1 <- sort(d1) # Q1-9 d1, d2  오름차순으로 정렬 후 각 10개씩을 추출하여 d3에 저장
D2 <- sort(d2)
d3 <- D1[1,10] + D2[1,10]
D1 <- sort(d1) # Q1-9 d1, d2  오름차순으로 정렬 후 각 10개씩을 추출하여 d3에 저장
D2 <- sort(d2)
d3 <- D1[1,10] + D2[1,10]
D1 <- sort(d1) # Q1-9 d1, d2  오름차순으로 정렬 후 각 10개씩을 추출하여 d3에 저장
D2 <- sort(d2)
d3 <- D1[1,10] & D2[1,10]
D1 <- sort(d1) # Q1-9 d1, d2  오름차순으로 정렬 후 각 10개씩을 추출하여 d3에 저장
D2 <- sort(d2)
d3 <- D1[1,10] & D2[1,10]
d3 <- sort(d1[1,10]) & sort(D2[1,10]) # Q1-9 d1, d2  오름차순으로 정렬 후 각 10개씩을 추출하여 d3에 저장
d3 <- sort(d1[1:10]) & sort(D2[1:10]) # Q1-9 d1, d2  오름차순으로 정렬 후 각 10개씩을 추출하여 d3에 저장
d1[1:10]
d3 <- union(sort(d1[1:10]), sort(D2[1:10])) # Q1-9 d1, d2  오름차순으로 정렬 후 각 10개씩을 추출하여 d3에 저장
x <- sort(d1[1:10])
y <- sort(d2[1:10])
d3 < union(x,y)
x
x + y
x & y
v1[v1 < 60] # Q2-1
v1 <- 51:90
v1[v1 < 60] # Q2-1
length[v1 < 70] # Q2-2
length[v1 < 70] # Q2-2
sum[v1 < 70] # Q2-2
sum([v1 < 70]) # Q2-2
sum(v1 < 70) # Q2-2
sum(v1 [v1> 65])
v1[v1 > 60 & v1 < 73]
v1[v1 < 65 or v1 > 80] # Q2-5
v1[v1 < 65 | v1 > 80] # Q2-5
v1[v1 < 65 | v1 > 80] # Q2-5
for (s in v1){
if (s %% 7 == 3){
print(S, ' ')
}
}
for (s in v1){
if (s %% 7 == 3){
print(S, ' ')
}
}
v1[v1 %% 7 == 3]  # Q2-6 ??????????????????????
v1[0 <- v1 %% 7 == 0]
v1
v1[0 <- (v1 %% 7 == 0)]
v1
v1[v1 %% 7 == 3]  # Q2-6
v1[v1 %% 7 == 0]
v1[v1 %% 7 == 0] <- 0
v1
sum(v1 %% 2 == 0)
sum[(v1 %% 2 == 0)]
sum[v1 (v1 %% 2 == 0)]
sum[(v1 %% 2 == 0)]
sum(v1 [v1 %% 2 == 0])
v1[v1 %% 2 == 0 | v1 > 80]
v1[v1 %% 2 == 1 | v1 > 80]
v1[v1 %% (3*5) == 0]
v1[v1 %% 2 == 0]
v1 <- v1[v1 %% 2 == 0] * 2
v1
setdiff(v1, v1[v1 %% 7 == 0]) # Q2-12
d3 <- union(sort(d1[1:10]), sort(D2[1:10])) # Q1-9 d1, d2  오름차순으로 정렬 후 각 10개씩을 추출하여 d3에 저장
d3 <- union(sort(d1), sort(D2)) # Q1-9 d1, d2  오름차순으로 정렬 후 각 10개씩을 추출하여 d3에 저장
d3 <- union(sort(d1), sort(D2)) # Q1-9 d1, d2  오름차순으로 정렬 후 각 10개씩을 추출하여 d3에 저장
d3
d3 <- union(head(sort(d1)), 10), head(sort(d2)), 10)) # Q1-9 d1, d2  오름차순으로 정렬 후 각 10개씩을 추출하여 d3에 저장
d3
d3 <- union((head(sort(d1)), 10), head(sort(d2)), 10)) # Q1-9 d1, d2  오름차순으로 정렬 후 각 10개씩을 추출하여 d3에 저장
d3
d3 <- union((head(sort(d1)), 10), head(sort(d2)), 10) # Q1-9 d1, d2  오름차순으로 정렬 후 각 10개씩을 추출하여 d3에 저장
d3 <- union((head(sort(d1)), 10), (head(sort(d2)), 10)) # Q1-9 d1, d2  오름차순으로 정렬 후 각 10개씩을 추출하여 d3에 저장
d3 <- union( head(sort(d1), 10), head(sort(d2), 10)) # Q1-9 d1, d2  오름차순으로 정렬 후 각 10개씩을 추출하여 d3에 저장
d3
cat(d1, d2) # Q1-1
length(d2) # Q1-2
d1 + d2 # Q1-3
d2 - d1
d1 * d2
d2 / d1
sum(d1) # Q1-4
sum(d2)
sum(d1+d2) # Q1-5
max(d2); min(d2) # Q1-6
mean(d2) - mean(d1) # Q1-7
sort(d1, decreasing = TRUE) # Q1-8
d3 <- union( head(sort(d1), 10), head(sort(d2), 10)) # Q1-9 d1, d2  오름차순으로 정렬 후 각 10개씩을 추출하여 d3에 저장
d3
v1[v1 < 60] # Q2-1
sum(v1 < 70) # Q2-2
sum(v1 [v1> 65]) # Q2-3
v1 <- 51:90
v1[v1 < 60] # Q2-1
sum(v1 < 70) # Q2-2
sum(v1 [v1> 65]) # Q2-3
v1[v1 > 60 & v1 < 73] # Q2-4
v1[v1 < 65 | v1 > 80] # Q2-5
v1[v1 %% 7 == 3]  # Q2-6
v1[v1 %% 7 == 0] <- 0 # Q2-7
sum(v1 [v1 %% 2 == 0]) # Q2-8
v1[v1 %% 2 == 1 | v1 > 80] # Q2-9
v1[v1 %% (3*5) == 0] # Q2-10
v1 <- v1[v1 %% 2 == 0] * 2 # Q2-11
setdiff(v1, v1[v1 %% 7 == 0]) # Q2-12
x <- c(1,2,3)
y <- c(3,5,6)
z <- c(3,1,2)
w <- c(x,y); w
union (x,y) # 합집합
age <- c(30, 35, 40)
age
names(age) <- c("박재영", "김명중", "뚝딱이") #칼럼명 지정
age
a <- c(1:20) #벡터 객체 생성
a <- c(11:20) #벡터 객체 생성
a[13:18]
a[3:8]
v <- c(13, 5, 20:23, 12, -2:3)
v[2]
v[c(2,4)]
v[c(3:5)]
v[c(4,5:8,7)]
v[13]
v[10]
v[-1]
v[-c(2,4)]
list_one <- list("Pengsoo", "age", 10)
list_one
list_one <- unlist(list_one)
list_one
list_one <- list(c(1:5), c(8:10))
list_one
list_one <- list(name = c("펭수", "김명중"), age = c(10,63), gender = c("Unknown", "Male"))
list_one
$name
list_one$name
length(list_one)
x
x <- matrix(c(1:9), nrow=3, ncol = 3)
x
length(x)
apply(x, 1, mean)
apply(x, 2, mean)
f<-function(x)
x*c(1,2,3)
result <- apply(x,1,f)
result
colnames(x) <- c("one", "two", "three")
x
person.info
name <- c("KANG","PENGSOO","KIM")
age <- c(40, 32, 10)
gender <- factor(c("M","N","F"))
blood.type = factor(c("O","?","A"))
person.info <- data.frame(name,age,gender,blood.type)
person.info
person.info$name
person.info[person.info$name == "KANG"] #콤마 하나 안찍으면 다르다
person.info[person.info$name == "KANG",]
person.info[person.info$name == "KANG"] #콤마 하나 안찍으면 다르다
person2.info <- data.frame(name = c("KANG", "PENG","KIM"),
age = c(40,32,10),
gender = factor(c("M","N","F")),
blood.type = factor (c("O", "?","A")))
person2.info
mode(person.info)
class(person.info)
table(iris[, "Species"]) #often-used 팩터타입일때ㅑ 가능. 종류별 횟수 (중요)
table(person.info[ , "blood.type"])
head(iris) #often-used (중요)
head(iris, 1)
#Matrix/DataFrame 사용 함수
#행별/열별 합계와 평균 계산
colSums(iris[ ,-5]); apply(iris[ , 1:4], 2, sum) #5번째 열은 팩터형이라 연산 안됨. 수치형만 가능 2가 뭐야?
colSums(iris[ ,-5]);
colSums(iris)
colSums(iris[, 1:4])
iris[, 1:4]
rowsum(iris[, 1:4])
rowsum(iris[,-5])
rowSums(iris[,-5])
order(air)
order(multi_list)
multi_list <- list(c1 = list(1, 2, 3),
c2 = list(10, 20, 30),
c3 = list(100, 200, 300))
order(multi_list)
order(mtcars)
df = data.frame()
df = edit(df)
df
score <- matrix(c(10,40,60,20),
c(21,60,70,30))
score <- matrix(c(10,40,60,20),
c(21,60,70,30))
score
score <- matrix(c(10,40,60,20),
c(21,60,70,30), nrow=4, ncol=2)
score
score <- matrix(c(10,40,60,20),
c(21,60,70,30), nrow=4)
score
score <- matrix(c(10,40,60,20),
c(21,60,70,30), nrow=4)
score
score <- matrix(c(10,40,60,20),
c(21,60,70,30), nrow=4)
score
score <- matrix(c(10,40,60,20),
c(21,60,70,30), nrow=4, ncol=2)
score
colnames(score)<-c(m, f)
colnames(score)<-c("m", "f")
score
score <- matrix(c(10,40,60,20),
c(21,60,70,30), nrow=4, ncol=2, byrow=T)
score <- matrix(c(10,40,60,20),
c(21,60,70,30), nrow=4, ncol=2, byrow=T)
colnames(score)<-c("m", "f")
score
score <- matrix(c(10,40,60,20),
c(21,60,70,30), nrow=4, ncol=2, byrow=F)
colnames(score)<-c("m", "f")
score
x <- c(10,40,60,20)
y <- c(21,60,70,30)
score <- rbind(x,y)
score
x <- c(10,40,60,20)
y <- c(21,60,70,30)
score <-cbind(x,y)
score
colnames(score)<-c("m", "f")
2. score의 열 이름을 각각 male, female로 바꾸시오
score
colnames(score <- c("male", "female")); score
colnames(score) <- c("male", "female"); score
x <- c(10,40,60,20)
y <- c(21,60,70,30)
score <-cbind(x,y)
score
colnames(score)<-c("m", "f")
score
colnames(score) <- c("male", "female"); score
#3. 2행에 있는 모든 값을 출력
score[2, ]
#4. female의 모든 값을 출력
score[, "female"]
#5. 3행 2열의 값을 출력
score[3,2]
st <- data.frame(state.x77); st
st <- data.frame(state.x77); class(st)
#2. st의 내용을 출력
st
#3. st의 열 이름 출력
colnames(st)
#4. st의 행 이름 출력
rownames(st)
nrow(st)
#5. st의 행의 개수와 열의 개수 출력
dim(St)
#5. st의 행의 개수와 열의 개수 출력
dim(st)
#6. st의 요약 정보 출력
str(st)
#7. st의 행별 합계와 평균 출력
rowSums(st); rowMeans(st)
rowSums(st)
#8. st의 열별 합계와 평균 출력
colSums(st);
#8. st의 열별 합계와 평균 출력
colSums(st); colMeans(st)
#9. Florida 주의 모든 정보 출력
st["Florida",]
#10. 50개 주의 수입(Income) 정보만 출력
st[, "Income"]
#11. Texas 주의 면적(Area)을 출력
st["Texas", "Area"]
#12. Ohio 주의 인구(Population)와 수입(Income) 출력
st["Ohio", c("Population", "Income")]
#13. 인구가 5,000 이상인 주의 데이터만 출력
st13 <- subset(st[, "Population"] > 5000)
#13. 인구가 5,000 이상인 주의 데이터만 출력
st13 <- subset(st, Population > 5000); st13
#14. 수입이 4,500 이상인 주의 인구, 수입, 면적을 출력
st13 <- subset(st, Income > 4500); st[, c("Population", "Income", "Area")]
#14. 수입이 4,500 이상인 주의 인구, 수입, 면적을 출력
st13 <- subset(st, Income > 4500); st13[, c("Population", "Income", "Area")]
#15. 수입이 4,500 이상인 주는 몇 개인지 출력
nrow(st13)
#16. 전체 면적(Area)이 100,000 이상이고, 결빙일수(Frost)가 120 이상인 주의 정보 출력
st16 <- subset(st, Area > 100000 & Frost > 120); st16
#15. 수입이 4,500 이상인 주는 몇 개인지 출력
st15 <- subset(st, Income > 4500); length(st15)
length(st13)
#15. 수입이 4,500 이상인 주는 몇 개인지 출력
nrow(st13)
#15. 수입이 4,500 이상인 주는 몇 개인지 출력
nrow(st13)
#15. 수입이 4,500 이상인 주는 몇 개인지 출력
st13
#15. 수입이 4,500 이상인 주는 몇 개인지 출력
nrow(st13)
#17. 인구(Population)가 2,000 미만이고, 범죄율(Murder)이 12미만인 주의 정보 출력
st17 <- subset(st, Population < 2000 & Murder < 12); st17
#18. 문맹률(Illiteracy)이 2.0 이상인 주의 평균 수입은 얼마인지 출력
st18 <- subset(st, Illiteracy > 2.0); colMeans(st18[, "Income"]
19. 문맹률(Illiteracy)이 2.0 미만인 주와 2.0 이상인 주의 평균 수입의 차이 출력
20. 기대수명(Life Exp)이 가장 높은 주는 어디인지 출력
21 Pennsylvania 주보다 수입(Income)이 높은 주들 출력
문3)
#18. 문맹률(Illiteracy)이 2.0 이상인 주의 평균 수입은 얼마인지 출력
st18 <- subset(st, Illiteracy > 2.0); colMean(st18[, "Income"]
19. 문맹률(Illiteracy)이 2.0 미만인 주와 2.0 이상인 주의 평균 수입의 차이 출력
20. 기대수명(Life Exp)이 가장 높은 주는 어디인지 출력
21 Pennsylvania 주보다 수입(Income)이 높은 주들 출력
문3)
#18. 문맹률(Illiteracy)이 2.0 이상인 주의 평균 수입은 얼마인지 출력
st18 <- subset(st, Illiteracy > 2.0); colMeans(st18[, "Income"])
#18. 문맹률(Illiteracy)이 2.0 이상인 주의 평균 수입은 얼마인지 출력
st18 <- subset(st, Illiteracy > 2.0); st18
#18. 문맹률(Illiteracy)이 2.0 이상인 주의 평균 수입은 얼마인지 출력
st18 <- subset(st, Illiteracy > 2.0); mean(st18[, "Income"])
st181 <- subset(st[, "Income"]); st181
st181 <- subset(st, st[, "Income"]); st181
st18[, "Income"]
abs(mean(st191[,"Income"]) - mean(st192[,"Income"]))
st191 <- subset(st, Illiteracy < 2.0);
st192 <- subset(st, Illiteracy > 2.0);
abs(mean(st191[,"Income"]) - mean(st192[,"Income"]))
#20. 기대수명(Life Exp)이 가장 높은 주는 어디인지 출력
max(st[,"Life.Exp"])
#20. 기대수명(Life Exp)이 가장 높은 주는 어디인지 출력
st20 <- subset(st, Life.Exp == max(st[,"Life.Exp"]));st20
#20. 기대수명(Life Exp)이 가장 높은 주는 어디인지 출력
st20 <- subset(st, Life.Exp == max(st[,"Life.Exp"])); rownames(st20)
#21 Pennsylvania 주보다 수입(Income)이 높은 주들 출력
st21 <- subset(st, Income > st["Pennsylvania", "Income"]); st21
#21 Pennsylvania 주보다 수입(Income)이 높은 주들 출력
st21 <- subset(st, Income > st["Pennsylvania", "Income"]); rownames(st21)
class(mtcars)
str(mtcals)
str(mtcars)
#2. 이 데이터셋의 행의 개수와 열의 개수 출력
dim(mtcars)
#3. 이 데이터셋 열들의 자료형 출력
str(mtcars)
#4. 연비(mpg)가 가장 좋은 자동차 모델 출력
max(mtcars[, "mpg"])
#4. 연비(mpg)가 가장 좋은 자동차 모델 출력
mt4 <- subset(mtcars, mpg == max(mtcars[, "mpg"])); rownames(mt4)
#5. gear가 4인 자동차 모델 중 연비가 가장 낮은 모델 출력
min(mtcars[,"mpg"])
#5. gear가 4인 자동차 모델 중 연비가 가장 낮은 모델 출력
mt5 <- subset(mtcars, mpg == min(mtcars[,"mpg"])); mt5
#5. gear가 4인 자동차 모델 중 연비가 가장 낮은 모델 출력
mt5 <- subset(mtcars, mpg == min(mtcars[,"mpg"] & gear ==4)); mt5
mt5 <- subset(mtcars, mpg == min(mtcars[,"mpg"] & gear ==4)); mt5
#5. gear가 4인 자동차 모델 중 연비가 가장 낮은 모델 출력
mt5 <- subset(mtcars, gear == 4)); mt5
mt5 <- subset(mtcars, gear == 4)); mt5
#5. gear가 4인 자동차 모델 중 연비가 가장 낮은 모델 출력
mt5 <- subset(mtcars, gear == 4); mt5
mt51 <- subset(mt5, mpg == min(mt5[,"mpg"])); rownames(mt51)
mt5 <- subset(mtcars, gear == 4); mt5
mt51 <- subset(mt5, mpg == min(mt5[,"mpg"])); rownames(mt51)
mt51
mt5
#6. Honda Civic의 연비(mpg)와 gear 수 출력
mtcars["Honda Civic", c("mpg", "gear")]
#7. Pontiac Firebird 보다 연비가 좋은 자동차 모델 출력
mt7 <- subset(mtcars, mpg > mtcars["Pontiac Firebird", "mpg"])
#7. Pontiac Firebird 보다 연비가 좋은 자동차 모델 출력
mt7 <- subset(mtcars, mpg > mtcars["Pontiac Firebird", "mpg"]); mt7
#7. Pontiac Firebird 보다 연비가 좋은 자동차 모델 출력
mt7 <- subset(mtcars, mpg > mtcars["Pontiac Firebird", "mpg"]); rownames(mt7)
mt7 <- subset(mtcars, mpg > mtcars["Pontiac Firebird", "mpg"]); rownames(mt7)
#8. 자동차 모델들의 평균 연비 출력
mean(mtcars[, "mpg"])
#9. gear의 수 종류 출력
table(mtcars[, "gear"])
#1. 이 데이터셋의 자료구조 출력
class(airquality)
#2. 이 데이터셋의 앞쪽 일부분 내용만 출력
head(airquality)
class(air)
#1. 이 데이터셋의 자료구조 출력
class(air)
#1. 이 데이터셋의 자료구조 출력
class(airquality)
#2. 이 데이터셋의 앞쪽 일부분 내용만 출력
head(airquality)
air3[ ,c("Month","Day")]
#3. 기온(Temp)이 가장 높은 날은 언제인지 월(Month)과 일(Day) 출력
air3 <- subset(airquality, Temp == max(air[,"Temp"]))
air3[ ,c("Month","Day")]
airquality
#3. 기온(Temp)이 가장 높은 날은 언제인지 월(Month)과 일(Day) 출력
air3 <- subset(airquality, Temp == max(airquality[,"Temp"]))
air3[ ,c("Month","Day")]
#4. 6월달에 발생한 가장 강한 바람(Wind)의 세기 출력
max(airquality[,"Wind"])
#5. 7월 달의 평균 기온(Temp) 출력 #7월이 아니라 5월이겠죠?
mean(airquality[, "Temp"]) #자료 그대로 5월의 평균기온
#5. 7월 달의 평균 기온(Temp) 출력 #7월이 아니라 5월이겠죠?
airquality
#5. 7월 달의 평균 기온(Temp) 출력
airjuly <- subset(airquality, Month == 7); mean(airjuly[,"Temp"]
#5. 7월 달의 평균 기온(Temp) 출력
airjuly <- subset(airquality, Month == 7); mean(airjuly[,"Temp"]
#5. 7월 달의 평균 기온(Temp) 출력
airjuly <- subset(airquality, Month == 7); mean(airjuly[,"Temp"])
airquality
airjuly
#5. 7월 달의 평균 기온(Temp) 출력
airjuly <- subset(airquality, Month == 7); mean(airjuly[,"Temp"])
nrow(air[air$Ozone > 100,])
nrow(air[airquality$Ozone > 100,])
nrow(air[airquality$Ozone > 100])
nrow(air[airquality$Ozone > 100])
air6 <- subset(airquality, Ozone > 100); air6
air6 <- subset(airquality, Ozone > 100); nrow(air6)
stat <- subset(state.x77, Income > 5000); stat
stat <- subset(state.x77, Income > 5000); stat
class(state.x77)
stat <- subset(state.x77, Income > 5000); stat
stat <- subset(state.x77, "Income" > 5000); stat
stat <- subset(state.x77, "Income" > 5000); stat
#매트릭스 자료형은 5000 이상 필터링 안되나
stat1 <- subset(as.data.frame(state.x77), Income > 5000); stat1
stat2 <- stat1[, c("Income", "Population","Area")];
stat2 <- stat1[, c("Income", "Population","Area")]; stat2
write.csv(stat2, "rich_state.csv", row.names = T)
stat1 <- subset(as.data.frame(state.x77), Income > 5000);
stat2 <- stat1[, c("Income", "Population","Area")];
setwd ("C:/GitHub/BM_ClassMaterial_R")
write.csv(stat2, "rich_state.csv", row.names = T)
stat1 <- subset(as.data.frame(state.x77), Income > 5000);
stat2 <- stat1[, c("Income", "Population","Area")];
setwd ("C:/GitHub/BM_ClassMaterial_R")
write.csv(stat2, "rich_state.csv", row.names = T)
#2. 1.에서 만든 rich_state.csv파일을 읽어서 ds 변수에 저장한 후 ds 내용 출력
setwd ("C:/GitHub/BM_ClassMaterial_R")
ds <- read.csv("rich_state.csv", header = T)
ds
